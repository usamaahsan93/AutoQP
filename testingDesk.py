#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Dec  7 22:33:53 2018

@author: u215-iii
"""

from myQFn import QCircuit

from kueGP import kueGP
from random import randint
import numpy as np
import matplotlib.pyplot as plt
from QGates import gateArity , oracleBernsteinVazirani , oracleDeutschJozsa


def appendOracle(code,orcl):
    '''
    This function appends the oracle in the quantum code representation.
    It replaces the 'ORACLE' keyword in the code with orcl.
    Both the input parameters code and orcl are list of tuples, but code also contains
    a keyword ORACLE.
    
    INPUT : List of tuples
            code: This also contains a keyword ORACLE
            orcl: This list is appended in code at ORACLE Keyword
    
    OUTPUT: orcl is appended in code at ORACLE keyword position
            
    '''   
    idx=code.index('ORACLE')
    str1=code[0:idx]
    str2=code[idx+1:]
    str1.extend(orcl)
    str1.extend(str2)
    return str1

def fitnessBernsteinVazirani(code):
    '''
    This function is used as a genetic programming fitness function.
    This is designed for the Bernstein-Vazirani Problem, for which quantum code
    is generated by our program.
    
    INPUT: List of tuples i.e. individual of genetic program
    
    OUTPUT: Fitness score of the individual
    
    '''

    count=10
    same_a=10

    # Looping is done count times
    v = 0
    for i in range(count):
        a=randint(0,7)
        y='{0:03b}'.format(a)
        yi =  np.array(list(y),dtype = np.float)      
        y1n = np.linalg.norm(np.ones(len(yi))) ;
        # For same 'a' output is computed 
        for i in range(same_a):
            # Initializing and constructing Q-circuit
            ckt=QCircuit(qBit=4,cBit=3)
            orcl=oracleBernsteinVazirani(y)

            str1=appendOracle(code,orcl)
            ckt.constructCircuit(str1)

            ckt.measurement([(1,0),(2,1),(3,2)],useHadamard=True)
    
            # Simulating and getting result
            result=ckt.evaluate()
            
            output=result.get_counts()
            out=list(output.keys())[0]
            outi = np.array(list(out),dtype = np.float)
            v+=y1n-np.linalg.norm(outi-yi)
            
    v=v/(count*same_a*y1n)
    return v


def fitnessDeutschJozsa(code):
    '''
    This function is used as a genetic programming fitness function.
    This is designed for the DeutschJozsa Problem, for which quantum code
    is generated by our program.
    
    INPUT: List of tuples i.e. individual of genetic program
    
    OUTPUT: Fitness score of the individual
    
    '''
    
    run=100
    fitness=0
    totalCases=4
    for case in range(totalCases):
        if case==0 or case == 3:
            a=1
        else:
            a=0
        
        err=0
        for runAtSameString in range(run):
            ckt=QCircuit(qBit=2,cBit=1)
            orcl=oracleDeutschJozsa(case)
            finalCode=appendOracle(code,orcl)
            ckt.constructCircuit(finalCode)
            ckt.measurement([(0,0)],useHadamard=True)
            # Simulating and getting result
            result=ckt.evaluate()
            
            output=result.get_counts()
            out=list(output.keys())[0]
            
            y=int(out)

            err+=np.linalg.norm(a-y)  
        fitness+=1-(err/run)
        
    fitness=fitness/totalCases
    return fitness
            



#op=list(gateArity.keys())

# RUN THIS SINGLE TIME RIGHT NOW
x=kueGP(population=1000, qBits=4,
        maxIndividualSize=30,
        fitnessFn=fitnessBernsteinVazirani,
        eliteUnit=10,
        mutationRate=0.5,
        maxIndividualSizeProbability=0.8,
        crossoverRate=0.7,
        generations=50,      
        stoppingCriteria=0.999999)

y,allfitness=x.fit()

plt.figure()
plt.plot(allfitness)
plt.xlabel('Generation')
plt.ylabel('Fitness')
plt.grid()
plt.title('Fitness Curve')